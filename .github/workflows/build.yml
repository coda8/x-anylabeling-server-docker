name: Build and Push Docker Images

on:
  # 不自动检查更新；请订阅上游 releases 后手动触发构建（见 README）
  # 订阅方式：在 https://github.com/CVHub520/X-AnyLabeling-Server 点 Watch → Custom → 勾选 Releases
  workflow_dispatch:
    inputs:
      version:
        description: '指定要构建的版本 (tag 或 branch，留空则自动检测最新版本)'
        required: false
        default: ''
      force_build:
        description: '强制构建（即使版本已存在）'
        required: false
        default: 'false'
        type: boolean

  # 当 Dockerfile、version.json（由 update-version 推送）或工作流更新时触发
  push:
    branches:
      - main
    paths:
      - 'Dockerfile'
      - 'Dockerfile.cuda'
      - 'version.json'
      - 'README.md'
      - '.github/workflows/build.yml'

env:
  REGISTRY: ghcr.io
  UPSTREAM_REPO: CVHub520/X-AnyLabeling-Server
  # 镜像名称将使用小写的仓库名
  IMAGE_NAME: ${{ github.repository }}

jobs:
  check-upstream:
    runs-on: ubuntu-latest
    outputs:
      should_build: ${{ steps.check.outputs.should_build }}
      version: ${{ steps.check.outputs.version }}
      is_release: ${{ steps.check.outputs.is_release }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check for new upstream version
        id: check
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # 如果手动指定了版本
          if [ -n "${{ github.event.inputs.version }}" ]; then
            VERSION="${{ github.event.inputs.version }}"
            echo "使用手动指定的版本: $VERSION"
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "is_release=false" >> $GITHUB_OUTPUT
            
            if [ "${{ github.event.inputs.force_build }}" == "true" ]; then
              echo "should_build=true" >> $GITHUB_OUTPUT
            else
              # 检查镜像是否已存在
              if docker manifest inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${VERSION} > /dev/null 2>&1; then
                echo "版本 $VERSION 已存在，跳过构建"
                echo "should_build=false" >> $GITHUB_OUTPUT
              else
                echo "should_build=true" >> $GITHUB_OUTPUT
              fi
            fi
            exit 0
          fi

          # 优先使用 version.json 中记录的跟随版本（由 update-version 工作流维护）
          if [ -f version.json ]; then
            FOLLOWED=$(jq -r '.version // ""' version.json)
            if [ -n "$FOLLOWED" ]; then
              VERSION="$FOLLOWED"
              IS_RELEASE="true"
              echo "使用 version.json 中的跟随版本: $VERSION"
              echo "version=$VERSION" >> $GITHUB_OUTPUT
              echo "is_release=$IS_RELEASE" >> $GITHUB_OUTPUT
              IMAGE_TAG="${VERSION}"
              echo "${{ secrets.GITHUB_TOKEN }}" | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin
              if docker manifest inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${IMAGE_TAG} > /dev/null 2>&1; then
                echo "版本 $IMAGE_TAG 的镜像已存在，跳过构建"
                echo "should_build=false" >> $GITHUB_OUTPUT
              else
                echo "需要构建版本 $IMAGE_TAG"
                echo "should_build=true" >> $GITHUB_OUTPUT
              fi
              exit 0
            fi
          fi

          # 获取上游最新 release
          LATEST_RELEASE=$(gh api repos/${{ env.UPSTREAM_REPO }}/releases/latest --jq '.tag_name' 2>/dev/null || echo "")
          
          if [ -n "$LATEST_RELEASE" ]; then
            VERSION="$LATEST_RELEASE"
            IS_RELEASE="true"
            echo "找到最新 release: $VERSION"
          else
            # 如果没有 release，获取最新 tag
            LATEST_TAG=$(gh api repos/${{ env.UPSTREAM_REPO }}/tags --jq '.[0].name' 2>/dev/null || echo "")
            
            if [ -n "$LATEST_TAG" ]; then
              VERSION="$LATEST_TAG"
              IS_RELEASE="false"
              echo "找到最新 tag: $VERSION"
            else
              # 如果也没有 tag，使用 main 分支的最新 commit
              LATEST_COMMIT=$(gh api repos/${{ env.UPSTREAM_REPO }}/commits/main --jq '.sha[:7]' 2>/dev/null || echo "")
              VERSION="main-${LATEST_COMMIT}"
              IS_RELEASE="false"
              echo "使用 main 分支: $VERSION"
            fi
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "is_release=$IS_RELEASE" >> $GITHUB_OUTPUT

          # 检查镜像是否已存在（对于 release 版本）
          IMAGE_TAG="${VERSION}"
          
          # 登录检查镜像是否存在
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin
          
          if docker manifest inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${IMAGE_TAG} > /dev/null 2>&1; then
            echo "版本 $IMAGE_TAG 的镜像已存在，跳过构建"
            echo "should_build=false" >> $GITHUB_OUTPUT
          else
            echo "需要构建版本 $IMAGE_TAG"
            echo "should_build=true" >> $GITHUB_OUTPUT
          fi

  build-cpu:
    needs: check-upstream
    if: needs.check-upstream.outputs.should_build == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Free disk space
        run: |
          sudo rm -rf /usr/share/dotnet
          sudo rm -rf /opt/ghc
          sudo rm -rf /usr/local/share/boost
          sudo rm -rf "$AGENT_TOOLSDIRECTORY"
          df -h

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=${{ needs.check-upstream.outputs.version }}
            type=raw,value=${{ needs.check-upstream.outputs.version }}-cpu
            type=raw,value=latest,enable=${{ needs.check-upstream.outputs.is_release == 'true' }}
            type=raw,value=cpu,enable=${{ needs.check-upstream.outputs.is_release == 'true' }}

      - name: Build and push CPU image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            VERSION=${{ needs.check-upstream.outputs.version }}
            PYTHON_VERSION=3.12
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64

  build-cuda:
    needs: check-upstream
    if: needs.check-upstream.outputs.should_build == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Free disk space
        run: |
          sudo rm -rf /usr/share/dotnet
          sudo rm -rf /opt/ghc
          sudo rm -rf /usr/local/share/boost
          sudo rm -rf "$AGENT_TOOLSDIRECTORY"
          df -h

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=${{ needs.check-upstream.outputs.version }}-cuda
            type=raw,value=${{ needs.check-upstream.outputs.version }}-cuda12.6
            type=raw,value=cuda,enable=${{ needs.check-upstream.outputs.is_release == 'true' }}
            type=raw,value=cuda12.6,enable=${{ needs.check-upstream.outputs.is_release == 'true' }}

      - name: Build and push CUDA image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.cuda
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            VERSION=${{ needs.check-upstream.outputs.version }}
            PYTHON_VERSION=3.12
            CUDA_VERSION=12.6.3
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64

  create-release:
    needs: [check-upstream, build-cpu, build-cuda]
    if: needs.check-upstream.outputs.is_release == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.check-upstream.outputs.version }}
          name: "X-AnyLabeling-Server Docker ${{ needs.check-upstream.outputs.version }}"
          body: |
            ## Docker 镜像

            此版本基于上游 [X-AnyLabeling-Server ${{ needs.check-upstream.outputs.version }}](https://github.com/${{ env.UPSTREAM_REPO }}/releases/tag/${{ needs.check-upstream.outputs.version }}) 自动构建。

            ### 拉取镜像

            **CPU 版本:**
            ```bash
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.check-upstream.outputs.version }}
            # 或
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.check-upstream.outputs.version }}-cpu
            ```

            **CUDA 版本 (需要 NVIDIA GPU):**
            ```bash
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.check-upstream.outputs.version }}-cuda
            ```

            ### 运行容器

            ```bash
            # CPU 版本
            docker run -d -p 8000:8000 ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.check-upstream.outputs.version }}

            # CUDA 版本
            docker run -d --gpus all -p 8000:8000 ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.check-upstream.outputs.version }}-cuda
            ```
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
